### 类的生命周期

![](/assets/201708080034.png)

JVM类加载过程可划分为三个过程：装载、链接和初始化

初始化过程不是加载类时必须触发的，但最迟必须在初次主动使用对象前执行，其所作的动作为给静态变量赋值、调用&lt;clinit&gt;\(\)等；

JVM通过类的全限定名+ClassLoader实例ID唯一标识一个被加载的类

##### 加载

加载阶段主要完成三件事，即通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构，在Java堆中生成一个代表此类的Class对象，作为访问方法区这些数据的入口。这个加载过程主要就是靠类加载器实现的，这个过程可以由用户自定义类的加载过程

##### 验证

这个阶段目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。  
主要包括四种验证：

1. 文件格式验证：基于字节流验证，验证字节流是否符合Class文件格式的规范，并且能被当前虚拟机处理；
2. 元数据验证：基于方法区的存储结构验证，对字节码描述信息进行语义验证；
3. 字节码验证：基于方法区的存储结构验证，进行数据流和控制流的验证；
4. 符号引用验证：基于方法区的存储结构验证，发生在解析中，是否可以将符号引用成功解析为直接引用

##### 准备

仅仅为类变量（即static修饰的字段变量）分配内存并且设置该类变量的初始值即零值，这里不包含用final修饰的static，因为final在编译的时候就会分配了（编译器的优化），同时这里也不会为实例变量分配初始化。类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中

##### 解析

解析主要就是将常量池中的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量，而直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。有类或接口的解析，字段解析，类方法解析，接口方法解析

##### 初始化

初始化阶段依旧是初始化类变量和其他资源，这里将执行用户的static字段和静态语句块的赋值操作。这个过程就是执行类构造器&lt; clinit &gt;方法的过程。  
&lt; clinit &gt;方法是由编译器收集类中所有类变量的赋值动作和静态语句块的语句生成的，类构造器&lt; clinit &gt;方法与实例构造器&lt; init &gt;方法不同，这里面不用显示的调用父类的&lt; clinit &gt;方法，父类的&lt; clinit &gt;方法会自动先执行于子类的&lt; clinit &gt;方法。即父类定义的静态语句块和静态字段都要优先子类的变量赋值操作

### 基本的加载流程

寻找jre目录，寻找jvm.dll，并初始化JVM；  
 产生一个Bootstrap Loader（启动类加载器）；  
 Bootstrap Loader，该加载器会加载它指定路径下的Java核心API，并且再自动加载Extended Loader（标准扩展类加载器），Extended Loader会加载指定路径下的扩展JavaAPI，并将其父Loader设为BootstrapLoader。  
 Bootstrap Loader也会同时自动加载AppClass Loader（系统类加载器），并将其父Loader设为ExtendedLoader。  
 最后由AppClass Loader加载CLASSPATH目录下定义的类，HelloWorld类。  
 创建自己的类加载器  
 在Java应用开发过程中，可能会需要创建应用自己的类加载器。典型的场景包括实现特定的Java字节代码查找方式、对字节代码进行加密/解密以及实现同名Java类的隔离等。创建自己的类加载器并不是一件复杂的事情，只需要继承自java.lang.ClassLoader类并覆写对应的方法即可

【参考资料】

[https://blog.csdn.net/CSDN\_980979768/article/details/47281037](https://blog.csdn.net/CSDN_980979768/article/details/47281037)

