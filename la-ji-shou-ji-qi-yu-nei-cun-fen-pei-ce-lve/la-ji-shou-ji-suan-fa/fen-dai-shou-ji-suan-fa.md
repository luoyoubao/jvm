### 分代收集算法\(Generational Collection\)

分代搜集算法是针对对象的不同特性，而使用适合的算法

### 增量回收

在对实时性要求很高的程序中，比起缩短GC的平均中断时间，往往更重视缩短GC的最大中断时间。例如，在机器人的姿势控制程序中，如果因为GC而让控制程序中断了0.1秒，机器人可能就摔倒了。或者，如果车辆制动控制程序因为GC而延迟响应的话，后果也是不堪设想的。在这些对实时性要求很高的程序中，必须能够对GC所产生的中断时间做出预测。例如，可以将“最多只能中断10毫秒”作为附加条件。在一般的GC算法中，作出这样的保证是不可能的，因为GC产生的中断时间与对象的数量和状态有关。

因此，为了维持程序的实时性，不等到GC全部完成，而是将GC操作细分成多个部分逐一执行。这种方式被称为增量回收（Incremental GC）。在增量回收中，由于GC过程是渐进的，在回收过程中程序本身会继续运行，对象之间的引用关系也可能会发生变化。如果已经完成扫描和标记的对象被修改，对新的对象产生了引用，这个新对象就不会被标记，明明是“存活”对象却被回收掉了。在增量回收中为了避免这样的问题，和分代回收一样也采用了写屏障。当已经被标记的对象的引用关系发生变化时，通过写屏障会将新被引用的对象作为扫描的起始点记录下来。由于增量回收的过程是分步渐进式的，可以将中断时间控制在一定长度之内。另一方面，由于中断操作需要消耗一定的时间，GC所消耗的总时间就会相应增加，正所谓有得必有失

