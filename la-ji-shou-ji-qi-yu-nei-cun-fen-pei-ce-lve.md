### 垃圾（Garbage） {#articleHeader1}

> 就是需要回收的对象

作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是GC的本质

### 根（Root） {#articleHeader2}

> 就是判断对象是否可被引用的起始点。

至于哪里才是根，不同的语言和编译器都有不同的规定，但基本上是将变量和运行栈空间作为根

### 垃圾收集器与内存分配策略

对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配

**1.对象优先在Eden分配** 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC

**2.大对象直接进入老年代**

* 所谓大对象是指需要大量连续内存空间的JAVA对象\(如长字符串和数组\)
* 经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间存放数据

**3.长期存活的对象将进入老年代**  
![](/assets/201708022223.png)

** 动态对象年龄判定**  
![](/assets/201708022225.png)

** 空间分配担保**  
![](/assets/20170802227.png)

